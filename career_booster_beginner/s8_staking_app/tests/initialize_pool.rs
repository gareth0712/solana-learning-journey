#![cfg(feature = "test-bpf")]
use borsh::{ BorshDeserialize, BorshSerialize };
use std::{ assert_eq, println, vec::Vec };

use solana_program::{ instruction::Instruction, pubkey::Pubkey };
use solana_sdk::{
  instruction::AccountMeta,
  signature::Keypair,
  signature::Signer,
  system_transaction,
  transaction::Transaction,
};
use solana_validator::test_validator::TestValidatorGenesis;
use s8_staking_app::{ instruction::Instruction as StakingInstruction, state::PoolStorageAccount };

#[test]
fn initialize_pool() {
  solana_logger::setup_with_default("solana_program_runtime=debug");
  // Generate program_id for the staking app
  let program_id: Pubkey = Pubkey::new_unique();
  println!("program_id: {:#?}", program_id);

  // Start testing environment
  // NOTE: remember that when you add_program, the first parameter should be the same as name parameter in [lib] section in Cargo.toml.
  let (test_validator, payer) = TestValidatorGenesis::default()
    .add_program("s8_staking_app", program_id)
    .start();
  let rpc_client = test_validator.get_rpc_client();

  // Generate pool authority and storage accounts
  // this code generates a new keypair that we will use as pool authority. In production, we will use a wallet or keypair generated by ‚Äúsolana-keygen new‚Äù command.
  let pool_authority = Keypair::new();
  println!("pool_authority: {:#?}", pool_authority.pubkey());
  // In the same way, we create a pool storage account, we can use just one account, but it‚Äôs considered bad practice to mess up authority and storage accounts.
  let pool_storage_account = Keypair::new();
  println!("pool_storage_account: {:#?}", pool_storage_account.pubkey());

  // üëå The next step is correctly configuring authority and storage to fulfill our program's constraints.
  const ALICE_INIT_BALANCE: u64 = 10_000_000_000;
  // generate a transaction that transfers 10 SOL from payer to pool_authority
  let airdrop_pool_owner_tx = system_transaction::transfer(
    &payer,
    &pool_authority.pubkey(),
    ALICE_INIT_BALANCE,
    rpc_client.get_latest_blockhash().unwrap() // The last parameter is just a helper for the runtime to correctly execute the transaction; it‚Äôs the block hash of the most recent block.
  );

  // Now the transaction is prepared and signed by payer keypair, we send it to our test validator with the following code rpc_client.send_and_confirm_transaction(&airdrop_pool_owner_tx).unwrap();
  rpc_client.send_and_confirm_transaction(&airdrop_pool_owner_tx).unwrap();

  // üëâ The final step is to create a pool storage account.
  const POOL_STORAGE_TOTAL_BYTES: usize = 32 + 8 + 8 + 8 + 1; // https://www.anchor-lang.com/docs/space
  // that is what ‚Äúsolana rent‚Äù command does, it calculates the rent exemption for the given account size
  let rent_exempt_balance = rpc_client
    .get_minimum_balance_for_rent_exemption(POOL_STORAGE_TOTAL_BYTES)
    .unwrap();

  // 1. creates an account for pool_storage_account,
  // 2. allocates POOL_STORAGE_TOTAL_BYTES,
  // 3. transfers rent_exempt_balance from pool_authority to pool_storage_account, (Transfer enough SOL from pool authority to rent exempt 57 bytes) and
  // 4. changes the owner to staking program_id.
  let create_pool_storage_account_tx = system_transaction::create_account(
    &pool_authority,
    &pool_storage_account,
    rpc_client.get_latest_blockhash().unwrap(),
    rent_exempt_balance,
    POOL_STORAGE_TOTAL_BYTES as u64,
    &program_id
  );

  rpc_client.send_and_confirm_transaction(&create_pool_storage_account_tx).unwrap();
  // ========================== End of test setup ==========================

  let initialize_ix = StakingInstruction::Initialize {
    rewards_per_token: 42,
  };
  let mut instruction_data: Vec<u8> = vec![];
  // Serialize instruction into bytes that would be given as instruction_data to the entrypoint!
  initialize_ix.serialize(&mut instruction_data).unwrap();

  // Create new transaction that will initialize pool
  // Each transaction may contain several instructions; that‚Äôs why the first parameter of Transaction::new_with_payer is an array of Instructions.
  // As you remember, Instruction is just packed parameters for the entry point function. The second parameter is an account that will pay a gas fee and have to sign the transaction.
  let mut transaction = Transaction::new_with_payer(
    // Instruction is what would be given to the entrypoint!
    &[
      Instruction {
        // program_id of the staking app program_id,
        program_id,
        // accounts required for Instruction::Initialize
        // 0. `[signer]` Pool Owner Wallet Account
        // 1. `[writable]` Pool Storage Account
        accounts: vec![
          AccountMeta::new(pool_authority.pubkey(), true),
          AccountMeta::new(pool_storage_account.pubkey(), false)
        ],
        // Borsh-packed Instruction::Initialize
        data: instruction_data,
      },
    ],
    // Signer of the transaction
    Some(&pool_authority.pubkey())
  );

  // Sign and send Initialize transaction
  transaction.sign(&[&pool_authority], rpc_client.get_latest_blockhash().unwrap());
  rpc_client.send_and_confirm_transaction(&transaction).unwrap();

  // Once the transaction is executed, we can check that the pool storage account has an expected state.
  // Fetch the pool storage account and verify that everything is initialized correctly
  let account_data = rpc_client.get_account_data(&pool_storage_account.pubkey()).unwrap();
  let pool_storage = PoolStorageAccount::try_from_slice(&account_data).unwrap();
  println!("pool_storage {:#?}", pool_storage);

  assert_eq!(pool_storage.pool_authority, pool_authority.pubkey());
  assert_eq!(pool_storage.total_staked, 0);
  assert_eq!(pool_storage.user_count, 0);
  assert_eq!(pool_storage.rewards_per_token, 42);
  assert!(pool_storage.is_initialized);
}
