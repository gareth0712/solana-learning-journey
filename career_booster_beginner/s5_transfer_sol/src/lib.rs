use borsh::{ BorshDeserialize, BorshSerialize };
use solana_program::{
  account_info::{ next_account_info, AccountInfo },
  entrypoint,
  entrypoint::ProgramResult,
  msg,
  program::invoke,
  program_error::ProgramError,
  pubkey::Pubkey,
  system_instruction,
};

// Declare and export the program's entrypoint
entrypoint!(process_instruction);
#[derive(BorshSerialize, BorshDeserialize)]
pub struct TransferInstruction {
  pub lamports: u64,
}

// Program entrypoint's implementation
pub fn process_instruction(
  program_id: &Pubkey,
  accounts: &[AccountInfo],
  instruction_data: &[u8]
) -> ProgramResult {
  msg!("Transfer $SOL example program_id {}", program_id);
  let accounts_iter = &mut accounts.iter();
  let from_account = next_account_info(accounts_iter)?;
  let to_account = next_account_info(accounts_iter)?;
  // we don't use given account as we rely on the system account received via system_program::id()
  // inside system_instruction::transfer, however you should check it with solana_program::system_program::check_id
  // 1) Why do we need to pass the system_program_account to the program? ========================
  // Without passing the System Program account, the transfer might fail because the System Program wouldn’t be properly referenced in the instruction. The Solana runtime needs the System Program account to validate that the operation is authorized and to actually perform the lamports transfer.
  // The following variable just demonstrates that system_program_account is also passed to the program; it will not be used
  let _system_program_account = next_account_info(accounts_iter)?;
  let lamports = TransferInstruction::try_from_slice(instruction_data)?.lamports;

  msg!("Transferring {} lamports from {} to {}", lamports, from_account.key, to_account.key);

  if from_account.lamports() < lamports {
    return Err(ProgramError::InsufficientFunds);
  }

  msg!("from_account balance {} is enough to transfer {}", from_account.lamports(), lamports);

  // 1) Why do we need to pass the system_program_account to the program? ========================
  // although the system_program_account isn’t explicitly used in the code, the invoke function asks the System Program to execute the Transfer instruction (it manages lamports transfers between accounts), and that’s why the System Program account needs to be passed.
  // When you invoke the transfer operation, the System Program’s logic gets executed to move the SOL from the from_account to the to_account.
  // The Solana runtime verifies that the System Program is involved in the transaction since it’s responsible for handling lamports transfers.

  // 2) Why we use invoke here instead of invoke_signed? =========================================
  // We don’t need to use invoke_signed in this case because the from_account is a regular account (not a Program-Derived Address (PDA)) that has a private key and has already signed the transaction when it was initiated.

  // 3) How cross program invocation is done? ====================================================
  // The transaction is handled by invoke and system_instruction::transfer. Our program calls other programs (system program) via invoke that works by similar rules as a transaction. We provide it with the instruction generated by `system_instruction::transfer` and the list of accounts with which the “transaction” will interact.
  invoke(
    &system_instruction::transfer(from_account.key, to_account.key, lamports),
    &[from_account.clone(), to_account.clone()]
  )
}

// The full system_instruction::tranfer function for reference:
// pub fn transfer(from_pubkey: &Pubkey, to_pubkey: &Pubkey, lamports: u64) -> Instruction {
//   let account_metas = vec![
//     AccountMeta::new(*from_pubkey, true),
//     AccountMeta::new(*to_pubkey, false)
//   ];
//   Instruction::new_with_bincode(
//     system_program::id(),
//     &(SystemInstruction::Transfer { lamports }),
//     account_metas
//   )
// }
